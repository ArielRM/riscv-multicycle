library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity uart is
	
	generic (
		constant SIZE : integer := 8
	);
	
	port(
		clk_in_1M	: in std_logic;
		clk_baud	: in std_logic;
		
		data_in		: in std_logic_vector(SIZE-1 downto 0);
		tx	 		: out std_logic;
		start	: in std_logic;
		tx_cmp		: out std_logic;
		
		data_out	: out std_logic_vector(SIZE-1 downto 0);
		rx			: in std_logic;
		rx_cmp		: out std_logic	
	);
end entity uart;

architecture RTL of uart is		
	type state_tx_type is (IDLE, MOUNT_BYTE, TRANSMIT, ERR);
	signal state_tx : state_tx_type := IDLE;
	signal cnt_tx	: integer := 0;
	
	signal state_rx : state_tx_type := IDLE;
begin	
	
	-- Máquina de estado TX: Moore
	estado_tx: process(clk_in_1M, start) is
	begin
		if rising_edge(clk_in_1M) then
			case state_tx is
				when IDLE =>
					if start = '1' then
						state_tx <= MOUNT_BYTE;
					else
						state_tx <= IDLE;
					end if;
				when MOUNT_BYTE =>
					if start = '0' then
						state_tx <= TRANSMIT;
					elsif start = '1' then
						state_tx <= ERR;
					end if;
				when TRANSMIT =>
					if start = '0' AND (cnt_tx < SIZE+1) then
						state_tx <= TRANSMIT;
					elsif start = '1' then
						state_tx <= ERR;
					else
						state_tx <= IDLE;
					end if;
				when ERR =>
					if start = '1' then
						state_tx <= IDLE;
					else
						state_tx <= ERR;
					end if;
			end case;
		end if;
	end process;
	
	-- Máquina MEALY: transmission
	tx_proc: process(state_tx, clk_baud, cnt_tx, data_in)
		variable to_tx 	: std_logic_vector(SIZE+1 downto 0);
	begin
		
		tx_cmp <= '0';
		--tx <= '1';
		
		case state_tx is
			when IDLE =>
				tx_cmp <= '1';
				tx <= '1';
				to_tx := (others => '0');
				
			when MOUNT_BYTE =>
				to_tx := '1' & data_in & '0';
				tx_cmp <= '0';
				tx <= '1';
			
			when TRANSMIT =>
				if rising_edge(clk_baud) AND (cnt_tx < SIZE+1) then
					tx <= to_tx(cnt_tx);
					cnt_tx <= cnt_tx + 1;
				end if;
			
			when ERR =>
				tx <= '1';
				tx_cmp <= '0';
				
		end case;
		
	end process;
	
end architecture RTL;
